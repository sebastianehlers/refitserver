using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using RefitServer.Generator.Extensions;

namespace RefitServer.Generator;

[Generator]
public class RefitControllerGenerator : ISourceGenerator
{
    public void Execute(GeneratorExecutionContext context)
    {
        Console.WriteLine("Executing RefitServe.Generator");
        
        var syntaxTrees = context.Compilation.SyntaxTrees;
        foreach (var syntaxTree in syntaxTrees)
        {
            var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);
            var classNodes = syntaxTree.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>();
            foreach (var classNode in classNodes)
            {
                var classSymbol = semanticModel.GetDeclaredSymbol(classNode);
                if (classSymbol is not INamedTypeSymbol namedType || !namedType.Interfaces.Any())
                    continue;

                var attribute = namedType.GetAttributes().FirstOrDefault(attr =>
                    attr.AttributeClass?.ToDisplayString() == "RefitServer.Attributes.GenerateRefitControllerAttribute");

                if (attribute == null)
                    continue;
                
                GenerateCode(context, namedType, attribute);
            }
        }
    }

    private void GenerateCode(GeneratorExecutionContext context, INamedTypeSymbol namedType, AttributeData generateAttribute)
    {
        var wrappedMethods = new LinkedList<string>();
        
        foreach (var interfaceType in namedType.Interfaces)
        {
            foreach (var interfaceMember in interfaceType.GetMembers().OfType<IMethodSymbol>())
            {
                var httpMethodAttribute = interfaceMember.GetAttributes().FirstOrDefault(IsRefitMethodAttribute);
                
                if (httpMethodAttribute == null)
                    continue;
                
                if (namedType.FindImplementationForInterfaceMember(interfaceMember) is IMethodSymbol implementingMethod)
                {
                    var constructorParams = httpMethodAttribute.AttributeConstructor?.Parameters
                        .Select(param => new { param.Name, Type = param.Type.ToDisplayString() })
                        .Zip(httpMethodAttribute.ConstructorArguments, (key, value) => new { key, value })
                        .ToArray();

                    if (constructorParams == null)
                        continue;
                    
                    var path = constructorParams.FirstOrDefault(arg => arg.key.Name == "path" && arg.key.Type == "string")?.value.Value as string 
                               ?? throw new NotSupportedException($"unable to find string path in constructor"); //TODO Better troubleshooting msg
                    var method = RefitMethodAttributeToHttpMethodString(httpMethodAttribute);

                    wrappedMethods.AddLast(GenerateWrapperMethod(interfaceMember, implementingMethod, method, path));
                }
            }
        }

        if (!wrappedMethods.Any())
            return;

        var usingsDeclaration = namedType.GetUsingsDeclarationString();
        var namespaceDeclaration = namedType.GetNamespaceDeclarationString();
        var generatedCode = 
            "// <auto-generated/> \n" +
            $"{usingsDeclaration} \n\n" +
            $"{namespaceDeclaration}\n\n" +
            $"public partial class {namedType.Name}\n" +
            "{\n" + string.Join("\n",wrappedMethods) + "\n}";

        context.AddSource(namedType.Name + ".g.cs", generatedCode); //TODO handle partials/controllers with same name but different namespace
    }
    
    private bool IsRefitMethodAttribute(AttributeData attr)
    {
        return attr.AttributeClass?.ToDisplayString() switch
        {
            "Refit.GetAttribute" => true,
            "Refit.PostAttribute" => true,
            "Refit.PutAttribute" => true,
            "Refit.PatchAttribute" => true,
            "Refit.DeleteAttribute" => true,
            "Refit.OptionsAttribute" => true,
            "Refit.HeadAttribute" => true,
            _ => false
        };
    }
    
    private string RefitMethodAttributeToHttpMethodString(AttributeData attr)
    {
        return attr.AttributeClass?.ToDisplayString() switch
        {
            "Refit.GetAttribute" => "Get",
            "Refit.PostAttribute" => "Post",
            "Refit.PutAttribute" => "Put",
            "Refit.PatchAttribute" => "Patch",
            "Refit.DeleteAttribute" => "Delete",
            "Refit.OptionsAttribute" => "Options",
            "Refit.HeadAttribute" => "Head",
            _ => throw new NotSupportedException($"Unsupported RefitMethodAttribute '{attr.AttributeClass?.ToDisplayString()}'")
        };
    }

    private string GenerateWrapperMethod(IMethodSymbol interfaceMethod, IMethodSymbol implementingMethod, string httpMethod, string route)
    {
        var returnType = implementingMethod.ReturnType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        var parameters = implementingMethod.Parameters
            .Zip(interfaceMethod.Parameters, (impParam, ifaceParam) => new { impParam, ifaceParam })
            .Select(pair => 
            {
                var bodyDataAttributeData = pair.ifaceParam.GetAttributes().FirstOrDefault(ifaceAttr => ifaceAttr.AttributeClass?.ToDisplayString() == "Refit.BodyAttribute");
                
                var fromBodyAttribute = bodyDataAttributeData != null ? "[Microsoft.AspNetCore.Mvc.FromBodyAttribute()]" : "";
                var attributes = GenerateAttributes(pair.impParam.GetAttributes(), "");
                var type = pair.impParam.Type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
                var parameterName = pair.impParam.Name;
                
                return $"{fromBodyAttribute}{attributes}{type} {parameterName}";
            })
            .Aggregate((p1, p2) => $"{p1}, {p2}");

        var methodAttributes = GenerateAttributes(implementingMethod.GetAttributes(), "\n");
        var originalCallParameters = string.Join(", ", implementingMethod.Parameters.Select(p => p.Name));

        return 
            $"{methodAttributes}\n[Http{httpMethod}(\"{route}\")]\n" + 
            $"public {returnType} {implementingMethod.Name}_grc({parameters})\n\t" + 
            $"=> {implementingMethod.Name}({originalCallParameters});";
    }

    private static string GenerateAttributes(ImmutableArray<AttributeData> attributes, string seperator)
    {
        return string.Join(seperator, attributes.Select(attr => {
            var attributeArguments = attr.ConstructorArguments
                .Select(SerializeArgument)
                .Concat(attr.NamedArguments.Select(namedArg => $"{namedArg.Key} = {SerializeArgument(namedArg.Value)}"));
            return $"[{attr.AttributeClass!.ToDisplayString()}({string.Join(", ", attributeArguments)})]";
        }));
    }

    private static string SerializeArgument(TypedConstant arg)
    {
        return arg.Kind switch
        {
            TypedConstantKind.Array => $"new[] {{{string.Join(", ", ((IEnumerable<TypedConstant>)arg.Value!).Select(SerializeArgument))}}}",
            TypedConstantKind.Type => $"typeof({arg.Value!})",
            TypedConstantKind.Enum => $"{arg.Type!.ToDisplayString()}." + Enum.GetName(arg.Value!.GetType(), arg.Value),
            TypedConstantKind.Primitive => arg.Type!.SpecialType switch
            {
                SpecialType.System_String => $"\"{arg.Value}\"",
                SpecialType.System_Boolean => arg.Value!.ToString()!.ToLowerInvariant(),
                _ => arg.Value!.ToString()!
            },
            _ => arg.Value?.ToString() ?? "null"
        };
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        Console.WriteLine("Initializing RefitServer.Generator");
    }
}